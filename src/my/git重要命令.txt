1.
安装完成后，还需要最后一步设置，在命令行输入：
$ git config --global user.name "Your Name"
$ git config --global user.email "email@example.com"
因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。
注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。

2. 本地版本库
$ mkdir learngit
$ cd learngit
$ pwd
pwd命令用于显示当前目录。mkdir表示新建文件夹

$ git init
通过git init命令把这个目录变成Git可以管理的仓库

$ git add readme.txt
git add告诉Git，把文件添加到仓库

$ git commit -m "wrote a readme file"
用命令git commit告诉Git，把文件提交到仓库

$ git add file1.txt
$ git add file2.txt file3.txt
$ git commit -m "add 3 files."

$ git add .
添加所有新改变

$ git status
git status命令可以让我们时刻掌握仓库当前的状态

git diff readme.txt
git diff顾名思义就是查看difference.

要随时掌握工作区的状态，使用git status命令。
如果git status告诉你有文件被修改过，用git diff可以查看修改内容。

$ git log [--pretty=oneline]
版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看
穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本

$ git reset --hard <commit_id前几位>
HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭

$ git reflog
git reflog查看命令历史，以便确定要回到未来的哪个版本(要重返未来)。 

我们把文件往Git版本库里添加的时候，是分两步执行的：
第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；
第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。
Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD

工作区 版本库(暂存区(Stage) 分支(Master))
git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支

第一次修改 -> git add -> 第二次修改 -> git commit
Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。
每次修改，如果不add到暂存区，那就不会加入到commit中

$ git diff HEAD -- readme.txt
用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别

$ git checkout -- file
git checkout -- readme.txt可以丢弃工作区的修改
把readme.txt文件在工作区的修改全部撤销，这里有两种情况：
1. 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
2. 一种是readme.txt已经添加到暂存区后又作了修改，现在，撤销修改就回到添加到暂存区后的状态。
总之，就是让这个文件回到最近一次git commit或git add时的状态。

$ git reset HEAD file
命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区

回退小结:
场景1：当你改乱了工作区某个文件的内容 想直接丢弃工作区的修改时 用命令git checkout -- file。
场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。
场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。

删除情况:
$ git rm test.txt
$ git commit
一是确实要从版本库中删除该文件，那就用命令git rm，并且git commit：

$ git checkout -- test.txt
另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本
git checkout其实是用版本库里的版本替换工作区的版本 无论工作区是修改还是删除 都可以一键还原。

命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件内容到最新版本，你会丢失最近一次提交后你修改的内容。

3. 远程仓库
	SSH key在个人主目录下(/Chen/)的.ssh文件夹下
	github上创建仓库
$ git remote add origin https://github.com/Durant35/learngit.git
本地关联远程库.添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库

$ git push -u origin master
把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。
由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。

$ git push origin master
把本地master分支的最新修改推送至GitHub！

	从远程库克隆
$ git clone git@github.com:Durant35/gitskills.git
$ git clone https://github.com/Durant35/gitskills.git
克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。
Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快

$ git push origin master
克隆后可以直接推送

4. 分支管理
$ git branch
查看当前分支

$ git checkout -b dev
<==> 	$ git branch dev
		$ git checkout dev
git checkout命令加上-b参数表示创建并切换

$ git merge dev
git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容

$ git branch -d dev
因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。

Git鼓励大量使用分支：
查看分支：git branch
创建分支：git branch <name>
切换分支：git checkout <name>
创建+切换分支：git checkout -b <name>
合并某分支到当前分支：git merge <name>
删除分支：git branch -d <name>

$ git merge feature1
Auto-merging readme.txt
CONFLICT (content): Merge conflict in readme.txt
Automatic merge failed; fix conflicts and then commit the result.

Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容

$ git log --graph --pretty=oneline --abbrev-commit
当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。
用git log --graph命令可以看到分支合并图。

准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward：
$ git merge --no-ff -m "merge with no-ff" dev

*分支管理原则*
首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；
干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；
每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。

Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作
$ git stash
$ git stash list
恢复的同时把stash内容也删了
$ git stash pop
当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。

如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。


查看远程库的信息，用git remote：
$ git remote

或者，用git remote -v显示更详细的信息 如果没有推送权限，就看不到push的地址
$ git remote -v

从远程库clone时，默认情况下，只能看到本地的master分支 要在dev分支上开发，就必须创建远程origin的dev分支到本地，用这个命令创建本地dev分支
$ git checkout -b dev origin/dev

小结
查看远程库信息，使用git remote -v；
本地新建的分支如果不推送到远程，对其他人就是不可见的；
从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；
在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；
建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；
从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。

标签
git log --pretty=oneline --abbrev-commit
$ git tag
查看标签
$ git tag <name>
$ git tag <name> <commit-id>
创建标签
$ git show <tagname>
查看标签信息
命令git push origin <tagname>可以推送一个本地标签；

命令git push origin --tags可以推送全部未推送过的本地标签；

命令git tag -d <tagname>可以删除一个本地标签；

命令git push origin :refs/tags/<tagname>可以删除一个远程标签。


在GitHub上，可以任意Fork开源仓库；
自己拥有Fork后的仓库的读写权限；
可以推送pull request给官方仓库来贡献代码。


忽略某些文件时，需要编写.gitignore；
.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！

